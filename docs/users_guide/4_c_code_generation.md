Generating C-code
=================

The numerical evaluation of function objects in `CasADi` normally takes place in *virtual machines*, implemented as part of `CasADi`’s symbolic framework. But `CasADi` also supports the generation of self-contained C-code for a large subset of function objects.

C-code generation is interesting for a number of reasons:

-   Speeding up the evaluation time. As a rule of thumb, the numerical evaluation of autogenerated code, compiled with code optimization flags, can be between 4 and 10 times faster than the same code executed in `CasADi`’s virtual machines.

-   Allowing code to be compiled on a system where `CasADi` is not installed, such as an embedded system. All that is needed to compile the generated code is a C compiler.

-   Debugging and profiling functions. The generated code is essentially a mirror of the evaluation that takes place in the virtual machines and if a particular operation is slow, this is likely to show up when analysing the generated code with a profiling tool such as `gprof`. By looking at the code, it is also possible to detect what is potentially done in a suboptimal way. If the code is very long and takes a long time to compile, it is an indication that some functions need to be broken up in smaller, but nested functions.

Syntax for generating code
--------------------------

Generated C code can be as simple as calling the `generate` member function for a `Function` instance.

``` python
# Python
x = MX.sym('x',2)
y = MX.sym('y')
f = Function('f',[x,y],\
      [x,sin(y)*x],\
      ['x','y'],['r','q'])
f.generate('gen.c')
```

``` matlab
% MATLAB
x = MX.sym('x',2);
y = MX.sym('y');
f = Function('f',{x,y},...
      {x,sin(y)*x},...
      {'x','y'},{'r','q'});
f.generate('gen.c');
```

\# Python x = MX.sym(’x’,2) y = MX.sym(’y’) f = Function(’f’,\[x,y\], \[x,sin(y)\*x\], \[’x’,’y’\],\[’r’,’q’\]) f.generate(’gen.c’)

This will create a C file `gen.c` containing the function `f` and all its dependencies and required helper functions. We will return to how this file can be used in Section using\_codegen and the structure of the generated code is described in Section c\_api below.

You can generate a C file containing multiple `CasADi` functions by working with `CasADi`’s `CodeGenerator` class:

``` python
# Python
f = Function('f',[x],[sin(x)])
g = Function('g',[x],[cos(x)])
C = CodeGenerator('gen.c')
C.add(f)
C.add(g)
C.generate()
```

``` matlab
% MATLAB
f = Function('f',{x},{sin(x)});
g = Function('g',{x},{cos(x)});
C = CodeGenerator('gen.c');
C.add(f);
C.add(g);
C.generate();
```

\# Python f = Function(’f’,\[x\],\[sin(x)\]) g = Function(’g’,\[x\],\[cos(x)\]) C = CodeGenerator(’gen.c’) C.add(f) C.add(g) C.generate()

Both the `generate` function and the `CodeGenerator` constructor take an optional options dictionary as an argument, allowing customization of the code generation. Two useful options are `main`, which generates a *main* entry point, and `mex`, which generates a *mexFunction* entry point:

``` python
# Python
f = Function('f',[x],[sin(x)])
opts = dict(main=True, \
            mex=True)
f.generate('ff.c',opts)
```

``` matlab
% MATLAB
f = Function('f',{x},{sin(x)});
opts = struct('main', true,...
              'mex', true);
f.generate('ff.c',opts);
```

\# Python f = Function(’f’,\[x\],\[sin(x)\]) opts = dict(main=True, mex=True) f.generate(’ff.c’,opts)

This enables executing the function from the command line and MATLAB, respectively, as described in Section using\_codegen below.

If you plan to link directly against the generated code in some C/C++ application, a useful option is `with_header`, which controls the creation of a header file containing declarations of the functions with external linkage, i.e. the API of the generated code, described in Section c\_api below.

Using the generated code
------------------------

The generated C code can be used in a number of different ways:

-   The code can be compiled into a dynamically linked library (DLL), from which a `Function` instance can be created using `CasADi`’s `external` function. Optionally, the user can rely on `CasADi` to carry out the compilation *just-in-time*.

-   The generated code can be compiled into MEX function and executed from MATLAB.

-   The generated code can be executed from the command line.

-   The user can link, statically or dynamically, the generated code to his or her C/C++ application, accessing the C API of the generated code.

-   The code can be compiled into a dynamically linked library and the user can then manually access the C API using `dlopen` on Linux/OS X or `LoadLibrary` on Windows.

This is elaborated in the following.

### `CasADi`’s `external` function

The `external` command allows the user to create a `Function` instance from a dynamically linked library with the entry points described by the C API described in Section c\_api. Since the autogenerated files are self-contained[2], the compilation – on Linux/OSX – can be as easy as issuing:

``` sh
gcc -fPIC -shared gen.c -o gen.so
```

from the command line. Or, equivalently using MATLAB’s `system` command or Python’s `os.system` command. Assuming `gen.c` was created as described in the previous section, we can then create a `Function` `f` as follows:

``` python
# Python
f = external('f', './ff.so')
print(f(3.14))
```

``` matlab
% MATLAB
f = external('f', './ff.so');
disp(f(3.14))
```

\# Python from os import system system(’gcc -fPIC -shared ff.c -o ff.so’) f = external(’f’, ’./ff.so’) print(f(3.14))

We can also rely on `CasADi` performing the compilation *just-in-time* using `CasADi`’s `Importer` class. This is a plugin class, which at the time of writing had two supported plugins, namely `'clang'`, which invokes the *LLVM/Clang* compiler framework (distributed with `CasADi`), and `'shell'`, which invokes the system compiler via the command line. The latter is only available on Linux/OS X:

``` python
# Python
C = Importer('ff.c','clang')
f = external('f',C);
print(f(3.14))
```

``` matlab
% MATLAB
C = Importer('ff.c','clang');
f = external('f',C);
disp(f(3.14))
```

print(”’ \[0.00159265, 0.00159265\] ”’)

We will return to the `external` function in Section external.

### Calling generated code from MATLAB

An alternative way of executing generated code is to compile the code into a MATLAB MEX function and call from MATLAB. This assumes that the `mex` option was set to “true” during the code generation, cf. Section codegen\_syntax. The generated MEX function takes the function name as its first argument, followed by the function inputs:

``` matlab
% MATLAB
mex ff.c -largeArrayDims
disp(ff('f', 3.14))
```

print(”’ Building with ’Xcode with Clang’. MEX completed successfully. (1,1) 0.0016 (2,1) 0.0016 ”’)

Note that the result of the execution is always a MATLAB sparse matrix.

### Calling generated code from the command line

Another option is to execute the generated code from the Linux/OSX command line. This is possible if the `main` option was set to “true” during the code generation, cf. Section codegen\_syntax. This is useful if you e.g. want to profile the generated with a tool such as `gprof`.

When executing the generated code, the function name is passed as a command line argument. The nonzero entries of all the inputs need to be passed via standard input and the function will return the output nonzeros for all the outputs via standard output:

``` sh
# Command line
echo 3.14 3.14 > ff_in.txt
gcc ff.c -o ff
./ff f < ff_in.txt > ff_out.txt
cat ff_out.txt
```

print(’0.00159265 0.00159265’)

### Linking against generated code from a C/C++ application

The generated code is written so that it can be linked with directly from a C/C++ application. If the `with_header` option was set to “true” during the code generation, a header file with declarations of all the exposed entry points of the file. Using this header file requires an understanding of `CasADi`’s codegen API, as described in Section c\_api below. Symbols that are *not* exposed are prefixed with a file-specific prefix, allowing an application to link against multiple generated functions without risking symbol conflicts.

### Dynamically loading generated code from a C/C++ application

A variant of above is to compile the generated code into a shared library, but directly accessing the exposed symbols rather than relying on `CasADi`’s `external` function. This also requires an understanding of the structure of the generated code.

In `CasADi`’s example collection, `codegen_usage.cpp` demonstrates how this can be done.

API of the generated code
-------------------------

The API of the generated code consists of a number of functions with external linkage. In addition to the actual execution, there are functions for memory management as well as meta information about the inputs and outputs. These functions are described in the following. Below, assume that the name of function we want to access is `fname`. To see what these functions actually look like in code and when they are called, we refer to the `codegen_usage.cpp` example.

### Reference counting

``` c
void fname_incref(void);
void fname_decref(void);
```

A generated function may need to e.g. read in some data or initialize some data structures before first call. This is typically not needed for functions generated from `CasADi` expressions, but may be required e.g. when the generated code contains calls to external functions. Similarly, memory might need to be deallocated after usage.

To keep track of the ownership, the generated code contains two functions for increasing and decreasing a reference counter. They are named `fname_incref` and `fname_decref`, respectively. These functions have no input argument and return void.

Typically, some initialization may take place upon the first call to `fname_incref` and subsequent calls will only increase some internal counter. The `fname_decref`, on the other hand, decreases the internal counter and when the counter hits zero, a deallocation – if any – takes place.

### Number of inputs and outputs

``` c
int fname_n_in(void);
int fname_n_out(void);
```

The number of function inputs and outputs can be obtained by calling the `fname_n_in` and `fname_n_out` functions, respectively. These functions take no inputs and return the number of input or outputs.

### Names of inputs and outputs

``` c
const char* fname_name_in(int ind);
const char* fname_name_out(int ind);
```

The functions `fname_name_in` and `fname_name_out` return the name of a particular input or output. They take the index of the input or output, starting with index 0, and return a `const char*` with the name as a null-terminated C string. Upon failure, these functions will return a null pointer.

### Sparsity patterns of inputs and outputs

``` c
const int* fname_sparsity_in(int ind);
const int* fname_sparsity_out(int ind);
```

The sparsity pattern for a given input or output is obtained by calling `fname_sparsity_in` and `fname_sparsity_out`, respectively. These functions take the input or output index and return a pointer to a field of constant integers (`const int*`). This is a compact representation of the *compressed column storage* (CCS) format that `CasADi` uses, cf. Section sparsity\_class. The integer field pointed to is structured as follows:

-   The first two entries are the number of rows and columns, respectively. In the following referred to as `nrow` and `ncol`.

-   The subsequent `ncol` + 1 entries are the nonzero offsets for each column, `colind` in the following. E.g. column *i* will consist of the nonzero indices ranging from `colind`\[*i*\] to `colind`\[*i* + 1\]. The last entry, `colind`\[`ncol`\], will be equal to the number of nonzeros, `nnz`.

-   Finally, *if* the sparsity pattern is *not dense*, i.e. if `nnz` ≠ `nrow` \* `ncol`, then the last `nnz` entries will contain the row indices.

Upon failure, these functions will return a null pointer.

### Maximum number of memory objects

``` c
int fname_n_mem(void);
```

A function may contain some mutable memory, e.g. for caching the latest factorization or keeping track of evaluation statistics. When multiple functions need to call the same function without conflicting, they each need to work with a different memory object. This is especially important for evaluation in parallel on a shared memory architecture, in which case each thread should access a different memory object.

The function `fname_n_mem` returns the maximum number of memory objects or 0 if there is no upper bound.

### Work vectors

``` c
int fname_work(int* sz_arg, int* sz_res, int* sz_iw, int* sz_w);
```

To allow the evaluation to be performed efficiently with a small memory footprint, the user is expected to pass four work arrays. The function `fname_work` returns the length of these arrays, which have entries of type `const double*`, `double*`, `int` and `double`, respectively.

The return value of the function is nonzero upon failure.

### Numerical evaluation

``` c
int fname(const double** arg, double** res,
          int* iw, double* w, int mem);
```

Finally, the function `fname`, performs the actual evaluation. It takes as input arguments the four work vectors and the index of the chosen memory object. The length of the work vectors must be at least the lengths provided by the command and the index of the memory object must be strictly smaller than the value returned by .

The nonzeros of the function inputs are pointed to by the first entries of the `arg` work vector and are unchanged by the evaluation. Similarly, the output nonzeros are pointed to by the first entries of the `res` work vector and are also unchanged (i.e. the pointers are unchanged, not the actual values).

The return value of the function is nonzero upon failure.


